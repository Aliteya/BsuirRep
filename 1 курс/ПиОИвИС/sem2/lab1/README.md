# Лабораторная работа 1

<b>Постановка задачи:</b> 
1. Разработать библиотеку для работы со структурой данных, указанной в
индивидуальном задании, на любом императивнойм языке
программирования (Pascal, C\C++, Java, C#, Python и др.)
2. Разработать тестовую программу, которая демонстрирует
работоспособность реализованной библиотеки работы со структурой
данных.
3. Разработать систему тестов, которые продемонстрировали бы
работоспособность реализованной библиотеки. Система тестов должна
отвечать требованиям полноты, адекватности и непротиворечивости.
Система тестов должна учитывать не только корректную работу на
правильных данных, но и предусматривать корректное завершение
программы в случае некорректных данных.

Структура данных: Квадродерево. Переход от матрицы к дереву. Переход от дерева к матрице.

<b>Определения:</b> 

- Дерево квадрантов (также квадродерево, 4-дерево, англ. quadtree) — дерево, в котором у каждого внутреннего узла ровно 4 потомка.

![500px-Quadtree](https://user-images.githubusercontent.com/112986008/221003324-ea79dc9c-2e31-4a27-85bd-e1453b5a7c5e.png)

- Дерево — одна из наиболее широко распространённых структур данных в информатике, эмулирующая древовидную структуру в виде набора связанных узлов. Является связным графом, не содержащим циклы. 
- Листья — это узлы, в которые входит 1 ветвь, причем не выходит ни одной.
- Начальный узел — это корень дерева (корневой узел).

<b>Реализованные классы и методы:</b>

<i>класс Node:</i>

Структура представлена классом узлов Node, которые включают в себя такие поля как:

val: поле, хранящее значения внутри узлов(по умолчанию -1 как значение корня).

isLeaf: поле отвечающее за то, является ли узел листом. True, если да, false, если нет.

topleft, topright, bottomleft, bottomright - поля, хранящие адреса потомков узла.

<i>методы:</i>

Переход от матрицы к дереву(вспомогательный private метод create и основной construct):

<i>create:</i> 

1. Пройдем по всем элементам текущей матрицы grid обозначив верхнюю левую координату за (x, y), а длину стороны за n.

2. Если все элементы матрицы одинаковы создаем и возвращаем узел leaf с соответствующим значением.

3. Если все значения не совпадают, создаем новый узел root, а затем выполняем рекурсивные вызовы четырех подматриц:

    3.1  Верхняя левая матрица с верхней левой координатой как (x, y).

    3.2  Верхняя правая матрица с верхней левой координатой как (x, y + n / 2).

    3.3  Нижняя левая матрица с верхней левой координатой как (x + n / 2, y).

    3.4  Нижняя правая матрица с верхней левой координатой как (x + n / 2, y + n / 2).

4. Назначим узлы, возвращенные этими рекурсивными вызовами, как соответствующие дочерние узлы root. 

5. Возвращаем root.

<i>conctruct:</i>

Вызывает метод create назначая параметры x, y.

Переход от дерева к матрице:

<i>quadtreetomatrixhelper:</i>

1. Если узел пуст, возвращаем 0.

2. Если все потомки узла пусты, начинаем обход дерева и присваеваем элементам матрицы значения полей val.

3. Рекурсивно вызываем функцию для каждого потомка дерева.

<i>to matrix:</i>

Вызывает метод quadtreetomatrixhelper назначая входные значения x, y и глубины дерева n.

<b>Достойны упоминания:</b>

<i>Функция n_checker:</i>

Так как квадродерево можно составить из матрицы сторона которой равна одной из степеней двойки, функция проверяет n и выдает соответствующее сообщение об ошибке 

<b>Источники вдохновения:</b>

https://otus.ru/journal/derevo-kak-struktura-dannyh

https://youtu.be/OJxEcs0w_kE

https://leetcode.com/problems/construct-quad-tree/discussion/

https://www.google.com/amp/s/iq.opengenus.org/quadtree/amp/
